import{cy as Ce,r as ke,c as ft}from"./index-15c7c175.js";var ci=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function ie(r){return r&&r.__esModule&&Object.prototype.hasOwnProperty.call(r,"default")?r.default:r}function hi(r){if(r.__esModule)return r;var e=r.default;if(typeof e=="function"){var t=function i(){if(this instanceof i){var n=[null];n.push.apply(n,arguments);var o=Function.bind.apply(e,n);return new o}return e.apply(this,arguments)};t.prototype=e.prototype}else t={};return Object.defineProperty(t,"__esModule",{value:!0}),Object.keys(r).forEach(function(i){var n=Object.getOwnPropertyDescriptor(r,i);Object.defineProperty(t,i,n.get?n:{enumerable:!0,get:function(){return r[i]}})}),t}const R=(r,e,t)=>`command_${r}_${e}_${t}`,he=(r,e,t)=>`endpoint_${r}_${e}_${t}`,ee=(r,e,t)=>`subscription_${r}_${e}_${t}`;function lt(r){try{return JSON.stringify(r)}catch{return'"[Circular]"'}}var pt=gt;function gt(r,e,t){var i=t&&t.stringify||lt,n=1;if(typeof r=="object"&&r!==null){var o=e.length+n;if(o===1)return r;var s=new Array(o);s[0]=i(r);for(var a=1;a<o;a++)s[a]=i(e[a]);return s.join(" ")}if(typeof r!="string")return r;var d=e.length;if(d===0)return r;for(var u="",h=1-n,c=-1,f=r&&r.length||0,p=0;p<f;){if(r.charCodeAt(p)===37&&p+1<f){switch(c=c>-1?c:0,r.charCodeAt(p+1)){case 100:case 102:if(h>=d||e[h]==null)break;c<p&&(u+=r.slice(c,p)),u+=Number(e[h]),c=p+2,p++;break;case 105:if(h>=d||e[h]==null)break;c<p&&(u+=r.slice(c,p)),u+=Math.floor(Number(e[h])),c=p+2,p++;break;case 79:case 111:case 106:if(h>=d||e[h]===void 0)break;c<p&&(u+=r.slice(c,p));var w=typeof e[h];if(w==="string"){u+="'"+e[h]+"'",c=p+2,p++;break}if(w==="function"){u+=e[h].name||"<anonymous>",c=p+2,p++;break}u+=i(e[h]),c=p+2,p++;break;case 115:if(h>=d)break;c<p&&(u+=r.slice(c,p)),u+=String(e[h]),c=p+2,p++;break;case 37:c<p&&(u+=r.slice(c,p)),u+="%",c=p+2,p++,h--;break}++h}++p}return c===-1?r:(c<f&&(u+=r.slice(c)),u)}const _e=pt;var yt=z;const Y=St().console||{},mt={mapHttpRequest:Q,mapHttpResponse:Q,wrapRequestSerializer:ae,wrapResponseSerializer:ae,wrapErrorSerializer:ae,req:Q,res:Q,err:$e,errWithCause:$e};function wt(r,e){return Array.isArray(r)?r.filter(function(i){return i!=="!stdSerializers.err"}):r===!0?Object.keys(e):!1}function z(r){r=r||{},r.browser=r.browser||{};const e=r.browser.transmit;if(e&&typeof e.send!="function")throw Error("pino: transmit option must have a send function");const t=r.browser.write||Y;r.browser.write&&(r.browser.asObject=!0);const i=r.serializers||{},n=wt(r.browser.serialize,i);let o=r.browser.serialize;Array.isArray(r.browser.serialize)&&r.browser.serialize.indexOf("!stdSerializers.err")>-1&&(o=!1);const s=Object.keys(r.customLevels||{}),a=["error","fatal","warn","info","debug","trace"].concat(s);typeof t=="function"&&a.forEach(function(m){t[m]=t}),(r.enabled===!1||r.browser.disabled)&&(r.level="silent");const d=r.level||"info",u=Object.create(t);u.log||(u.log=J),Object.defineProperty(u,"levelVal",{get:c}),Object.defineProperty(u,"level",{get:f,set:p});const h={transmit:e,serialize:n,asObject:r.browser.asObject,levels:a,timestamp:$t(r)};u.levels=bt(r),u.level=d,u.setMaxListeners=u.getMaxListeners=u.emit=u.addListener=u.on=u.prependListener=u.once=u.prependOnceListener=u.removeListener=u.removeAllListeners=u.listeners=u.listenerCount=u.eventNames=u.write=u.flush=J,u.serializers=i,u._serialize=n,u._stdErrSerialize=o,u.child=w,e&&(u._logEvent=fe());function c(){return this.level==="silent"?1/0:this.levels.values[this.level]}function f(){return this._level}function p(m){if(m!=="silent"&&!this.levels.values[m])throw Error("unknown level "+m);this._level=m,T(h,u,"error","log"),T(h,u,"fatal","error"),T(h,u,"warn","error"),T(h,u,"info","log"),T(h,u,"debug","log"),T(h,u,"trace","log"),s.forEach(function(E){T(h,u,E,"log")})}function w(m,E){if(!m)throw new Error("missing bindings for child Pino");E=E||{},n&&m.serializers&&(E.serializers=m.serializers);const _=E.serializers;if(n&&_){var x=Object.assign({},i,_),j=r.browser.serialize===!0?Object.keys(x):n;delete m.serializers,ne([m],j,x,this._stdErrSerialize)}function X(I){this._childLevel=(I._childLevel|0)+1,this.error=P(I,m,"error"),this.fatal=P(I,m,"fatal"),this.warn=P(I,m,"warn"),this.info=P(I,m,"info"),this.debug=P(I,m,"debug"),this.trace=P(I,m,"trace"),x&&(this.serializers=x,this._serialize=j),e&&(this._logEvent=fe([].concat(I._logEvent.bindings,m)))}return X.prototype=this,new X(this)}return u}function bt(r){const e=r.customLevels||{},t=Object.assign({},z.levels.values,e),i=Object.assign({},z.levels.labels,vt(e));return{values:t,labels:i}}function vt(r){const e={};return Object.keys(r).forEach(function(t){e[r[t]]=t}),e}z.levels={values:{fatal:60,error:50,warn:40,info:30,debug:20,trace:10},labels:{10:"trace",20:"debug",30:"info",40:"warn",50:"error",60:"fatal"}};z.stdSerializers=mt;z.stdTimeFunctions=Object.assign({},{nullTime:Oe,epochTime:Ue,unixTime:xt,isoTime:At});function T(r,e,t,i){const n=Object.getPrototypeOf(e);e[t]=e.levelVal>e.levels.values[t]?J:n[t]?n[t]:Y[t]||Y[i]||J,Et(r,e,t)}function Et(r,e,t){!r.transmit&&e[t]===J||(e[t]=function(i){return function(){const o=r.timestamp(),s=new Array(arguments.length),a=Object.getPrototypeOf&&Object.getPrototypeOf(this)===Y?Y:this;for(var d=0;d<s.length;d++)s[d]=arguments[d];if(r.serialize&&!r.asObject&&ne(s,this._serialize,this.serializers,this._stdErrSerialize),r.asObject?i.call(a,kt(this,t,s,o)):i.apply(a,s),r.transmit){const u=r.transmit.level||e.level,h=e.levels.values[u],c=e.levels.values[t];if(c<h)return;_t(this,{ts:o,methodLevel:t,methodValue:c,transmitLevel:u,transmitValue:e.levels.values[r.transmit.level||e.level],send:r.transmit.send,val:e.levelVal},s)}}}(e[t]))}function kt(r,e,t,i){r._serialize&&ne(t,r._serialize,r.serializers,r._stdErrSerialize);const n=t.slice();let o=n[0];const s={};i&&(s.time=i),s.level=r.levels.values[e];let a=(r._childLevel|0)+1;if(a<1&&(a=1),o!==null&&typeof o=="object"){for(;a--&&typeof n[0]=="object";)Object.assign(s,n.shift());o=n.length?_e(n.shift(),n):void 0}else typeof o=="string"&&(o=_e(n.shift(),n));return o!==void 0&&(s.msg=o),s}function ne(r,e,t,i){for(const n in r)if(i&&r[n]instanceof Error)r[n]=z.stdSerializers.err(r[n]);else if(typeof r[n]=="object"&&!Array.isArray(r[n]))for(const o in r[n])e&&e.indexOf(o)>-1&&o in t&&(r[n][o]=t[o](r[n][o]))}function P(r,e,t){return function(){const i=new Array(1+arguments.length);i[0]=e;for(var n=1;n<i.length;n++)i[n]=arguments[n-1];return r[t].apply(this,i)}}function _t(r,e,t){const i=e.send,n=e.ts,o=e.methodLevel,s=e.methodValue,a=e.val,d=r._logEvent.bindings;ne(t,r._serialize||Object.keys(r.serializers),r.serializers,r._stdErrSerialize===void 0?!0:r._stdErrSerialize),r._logEvent.ts=n,r._logEvent.messages=t.filter(function(u){return d.indexOf(u)===-1}),r._logEvent.level.label=o,r._logEvent.level.value=s,i(o,r._logEvent,a),r._logEvent=fe(d)}function fe(r){return{ts:0,messages:[],bindings:r||[],level:{label:"",value:0}}}function $e(r){const e={type:r.constructor.name,msg:r.message,stack:r.stack};for(const t in r)e[t]===void 0&&(e[t]=r[t]);return e}function $t(r){return typeof r.timestamp=="function"?r.timestamp:r.timestamp===!1?Oe:Ue}function Q(){return{}}function ae(r){return r}function J(){}function Oe(){return!1}function Ue(){return Date.now()}function xt(){return Math.round(Date.now()/1e3)}function At(){return new Date(Date.now()).toISOString()}function St(){function r(e){return typeof e<"u"&&e}try{return typeof globalThis<"u"||Object.defineProperty(Object.prototype,"globalThis",{get:function(){return delete Object.prototype.globalThis,this.globalThis=this},configurable:!0}),globalThis}catch{return r(self)||r(window)||r(this)||{}}}const Gt=ie(yt),L=Gt(),xe=(r,e)=>{var i,n,o,s,a,d;const t=r.subscribesTo;return L.debug({subscription:r,msg:e}),!(t.eventname&&t.eventname!==e.eventName||t.messageType&&t.messageType!==e.messageType||(i=t.sender)!=null&&i.name&&t.sender.name!==((n=e.sender)==null?void 0:n.serviceName)||(o=t.sender)!=null&&o.version&&t.sender.version!==((s=e.sender)==null?void 0:s.serviceVersion)||(a=t.sender)!=null&&a.target&&t.sender.target!==((d=e.sender)==null?void 0:d.serviceTarget))};var je=function(r){return function(e,t,i){return r(e,t,i)*i}},le=function(r,e){if(r)throw Error("Invalid sort config: "+e)},Ie=function(r){var e=r||{},t=e.asc,i=e.desc,n=t?1:-1,o=t||i;le(!o,"Expected `asc` or `desc` property"),le(t&&i,"Ambiguous object with `asc` and `desc` config properties");var s=r.comparer&&je(r.comparer);return{order:n,sortBy:o,comparer:s}},Nt=function(r){return function e(t,i,n,o,s,a,d){var u,h;if(typeof t=="string")u=a[t],h=d[t];else if(typeof t=="function")u=t(a),h=t(d);else{var c=Ie(t);return e(c.sortBy,i,n,c.order,c.comparer||r,a,d)}var f=s(u,h,o);return(f===0||u==null&&h==null)&&i.length>n?e(i[n],i,n+1,o,s,a,d):f}};function Te(r,e,t){if(r===void 0||r===!0)return function(o,s){return e(o,s,t)};if(typeof r=="string")return le(r.includes("."),"String syntax not allowed for nested properties."),function(o,s){return e(o[r],s[r],t)};if(typeof r=="function")return function(o,s){return e(r(o),r(s),t)};if(Array.isArray(r)){var i=Nt(e);return function(o,s){return i(r[0],r,1,t,e,o,s)}}var n=Ie(r);return Te(n.sortBy,n.comparer||e,n.order)}var ue=function(r,e,t,i){var n;return Array.isArray(e)?(Array.isArray(t)&&t.length<2&&(n=t,t=n[0]),e.sort(Te(t,i,r))):e};function ze(r){var e=je(r.comparer);return function(t){var i=Array.isArray(t)&&!r.inPlaceSorting?t.slice():t;return{asc:function(n){return ue(1,i,n,e)},desc:function(n){return ue(-1,i,n,e)},by:function(n){return ue(1,i,n,e)}}}}var Pe=function(r,e,t){return r==null?t:e==null?-t:typeof r!=typeof e?typeof r<typeof e?-1:1:r<e?-1:r>e?1:0},Ae=ze({comparer:Pe});ze({comparer:Pe,inPlaceSorting:!0});var ge={exports:{}},K=typeof Reflect=="object"?Reflect:null,Se=K&&typeof K.apply=="function"?K.apply:function(e,t,i){return Function.prototype.apply.call(e,t,i)},te;K&&typeof K.ownKeys=="function"?te=K.ownKeys:Object.getOwnPropertySymbols?te=function(e){return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))}:te=function(e){return Object.getOwnPropertyNames(e)};function Dt(r){console&&console.warn&&console.warn(r)}var Me=Number.isNaN||function(e){return e!==e};function b(){b.init.call(this)}ge.exports=b;ge.exports.once=Ut;b.EventEmitter=b;b.prototype._events=void 0;b.prototype._eventsCount=0;b.prototype._maxListeners=void 0;var Ge=10;function oe(r){if(typeof r!="function")throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof r)}Object.defineProperty(b,"defaultMaxListeners",{enumerable:!0,get:function(){return Ge},set:function(r){if(typeof r!="number"||r<0||Me(r))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+r+".");Ge=r}});b.init=function(){(this._events===void 0||this._events===Object.getPrototypeOf(this)._events)&&(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0};b.prototype.setMaxListeners=function(e){if(typeof e!="number"||e<0||Me(e))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+e+".");return this._maxListeners=e,this};function Re(r){return r._maxListeners===void 0?b.defaultMaxListeners:r._maxListeners}b.prototype.getMaxListeners=function(){return Re(this)};b.prototype.emit=function(e){for(var t=[],i=1;i<arguments.length;i++)t.push(arguments[i]);var n=e==="error",o=this._events;if(o!==void 0)n=n&&o.error===void 0;else if(!n)return!1;if(n){var s;if(t.length>0&&(s=t[0]),s instanceof Error)throw s;var a=new Error("Unhandled error."+(s?" ("+s.message+")":""));throw a.context=s,a}var d=o[e];if(d===void 0)return!1;if(typeof d=="function")Se(d,this,t);else for(var u=d.length,h=Be(d,u),i=0;i<u;++i)Se(h[i],this,t);return!0};function Fe(r,e,t,i){var n,o,s;if(oe(t),o=r._events,o===void 0?(o=r._events=Object.create(null),r._eventsCount=0):(o.newListener!==void 0&&(r.emit("newListener",e,t.listener?t.listener:t),o=r._events),s=o[e]),s===void 0)s=o[e]=t,++r._eventsCount;else if(typeof s=="function"?s=o[e]=i?[t,s]:[s,t]:i?s.unshift(t):s.push(t),n=Re(r),n>0&&s.length>n&&!s.warned){s.warned=!0;var a=new Error("Possible EventEmitter memory leak detected. "+s.length+" "+String(e)+" listeners added. Use emitter.setMaxListeners() to increase limit");a.name="MaxListenersExceededWarning",a.emitter=r,a.type=e,a.count=s.length,Dt(a)}return r}b.prototype.addListener=function(e,t){return Fe(this,e,t,!1)};b.prototype.on=b.prototype.addListener;b.prototype.prependListener=function(e,t){return Fe(this,e,t,!0)};function Lt(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,arguments.length===0?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function We(r,e,t){var i={fired:!1,wrapFn:void 0,target:r,type:e,listener:t},n=Lt.bind(i);return n.listener=t,i.wrapFn=n,n}b.prototype.once=function(e,t){return oe(t),this.on(e,We(this,e,t)),this};b.prototype.prependOnceListener=function(e,t){return oe(t),this.prependListener(e,We(this,e,t)),this};b.prototype.removeListener=function(e,t){var i,n,o,s,a;if(oe(t),n=this._events,n===void 0)return this;if(i=n[e],i===void 0)return this;if(i===t||i.listener===t)--this._eventsCount===0?this._events=Object.create(null):(delete n[e],n.removeListener&&this.emit("removeListener",e,i.listener||t));else if(typeof i!="function"){for(o=-1,s=i.length-1;s>=0;s--)if(i[s]===t||i[s].listener===t){a=i[s].listener,o=s;break}if(o<0)return this;o===0?i.shift():Ct(i,o),i.length===1&&(n[e]=i[0]),n.removeListener!==void 0&&this.emit("removeListener",e,a||t)}return this};b.prototype.off=b.prototype.removeListener;b.prototype.removeAllListeners=function(e){var t,i,n;if(i=this._events,i===void 0)return this;if(i.removeListener===void 0)return arguments.length===0?(this._events=Object.create(null),this._eventsCount=0):i[e]!==void 0&&(--this._eventsCount===0?this._events=Object.create(null):delete i[e]),this;if(arguments.length===0){var o=Object.keys(i),s;for(n=0;n<o.length;++n)s=o[n],s!=="removeListener"&&this.removeAllListeners(s);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if(t=i[e],typeof t=="function")this.removeListener(e,t);else if(t!==void 0)for(n=t.length-1;n>=0;n--)this.removeListener(e,t[n]);return this};function Ke(r,e,t){var i=r._events;if(i===void 0)return[];var n=i[e];return n===void 0?[]:typeof n=="function"?t?[n.listener||n]:[n]:t?Ot(n):Be(n,n.length)}b.prototype.listeners=function(e){return Ke(this,e,!0)};b.prototype.rawListeners=function(e){return Ke(this,e,!1)};b.listenerCount=function(r,e){return typeof r.listenerCount=="function"?r.listenerCount(e):Ve.call(r,e)};b.prototype.listenerCount=Ve;function Ve(r){var e=this._events;if(e!==void 0){var t=e[r];if(typeof t=="function")return 1;if(t!==void 0)return t.length}return 0}b.prototype.eventNames=function(){return this._eventsCount>0?te(this._events):[]};function Be(r,e){for(var t=new Array(e),i=0;i<e;++i)t[i]=r[i];return t}function Ct(r,e){for(;e+1<r.length;e++)r[e]=r[e+1];r.pop()}function Ot(r){for(var e=new Array(r.length),t=0;t<e.length;++t)e[t]=r[t].listener||r[t];return e}function Ut(r,e){return new Promise(function(t,i){function n(s){r.removeListener(e,o),i(s)}function o(){typeof r.removeListener=="function"&&r.removeListener("error",n),t([].slice.call(arguments))}qe(r,e,o,{once:!0}),e!=="error"&&jt(r,n,{once:!0})})}function jt(r,e,t){typeof r.on=="function"&&qe(r,"error",e,t)}function qe(r,e,t,i){if(typeof r.on=="function")i.once?r.once(e,t):r.on(e,t);else if(typeof r.addEventListener=="function")r.addEventListener(e,function n(o){i.once&&r.removeEventListener(e,n),t(o)});else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof r)}var It=ge.exports;function D(r){if(typeof r!="function")throw new Error("obliterator/iterator: expecting a function!");this.next=r}typeof Symbol<"u"&&(D.prototype[Symbol.iterator]=function(){return this});D.of=function(){var r=arguments,e=r.length,t=0;return new D(function(){return t>=e?{done:!0}:{done:!1,value:r[t++]}})};D.empty=function(){var r=new D(function(){return{done:!0}});return r};D.fromSequence=function(r){var e=0,t=r.length;return new D(function(){return e>=t?{done:!0}:{done:!1,value:r[e++]}})};D.is=function(r){return r instanceof D?!0:typeof r=="object"&&r!==null&&typeof r.next=="function"};var ye=D;const G=ie(ye);var me={};me.ARRAY_BUFFER_SUPPORT=typeof ArrayBuffer<"u";me.SYMBOL_SUPPORT=typeof Symbol<"u";var Tt=ye,He=me,zt=He.ARRAY_BUFFER_SUPPORT,Pt=He.SYMBOL_SUPPORT;function Mt(r){return typeof r=="string"||Array.isArray(r)||zt&&ArrayBuffer.isView(r)?Tt.fromSequence(r):typeof r!="object"||r===null?null:Pt&&typeof r[Symbol.iterator]=="function"?r[Symbol.iterator]():typeof r.next=="function"?r:null}var Ye=function(e){var t=Mt(e);if(!t)throw new Error("obliterator: target is not iterable nor a valid iterator.");return t},Rt=Ye,Ft=function(e,t){for(var i=arguments.length>1?t:1/0,n=i!==1/0?new Array(i):[],o,s=0,a=Rt(e);;){if(s===i)return n;if(o=a.next(),o.done)return s!==t&&(n.length=s),n;n[s++]=o.value}};const Je=ie(Ft);var Wt=ye,Kt=Ye,Vt=function(){var e=arguments,t=null,i=-1;return new Wt(function(){var o=null;do{if(t===null){if(i++,i>=e.length)return{done:!0};t=Kt(e[i])}if(o=t.next(),o.done===!0){t=null;continue}break}while(!0);return o})};const C=ie(Vt);function Bt(){const r=arguments[0];for(let e=1,t=arguments.length;e<t;e++)if(arguments[e])for(const i in arguments[e])r[i]=arguments[e][i];return r}let k=Bt;typeof Object.assign=="function"&&(k=Object.assign);function S(r,e,t,i){const n=r._nodes.get(e);let o=null;return n&&(i==="mixed"?o=n.out&&n.out[t]||n.undirected&&n.undirected[t]:i==="directed"?o=n.out&&n.out[t]:o=n.undirected&&n.undirected[t]),o}function $(r){return typeof r=="object"&&r!==null&&r.constructor===Object}function Xe(r){let e;for(e in r)return!1;return!0}function A(r,e,t){Object.defineProperty(r,e,{enumerable:!1,configurable:!1,writable:!0,value:t})}function N(r,e,t){const i={enumerable:!0,configurable:!0};typeof t=="function"?i.get=t:(i.value=t,i.writable=!1),Object.defineProperty(r,e,i)}function Ne(r){return!(!$(r)||r.attributes&&!Array.isArray(r.attributes))}function qt(){let r=Math.floor(Math.random()*256)&255;return()=>r++}class we extends Error{constructor(e){super(),this.name="GraphError",this.message=e}}class g extends we{constructor(e){super(e),this.name="InvalidArgumentsGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,g.prototype.constructor)}}class l extends we{constructor(e){super(e),this.name="NotFoundGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,l.prototype.constructor)}}class y extends we{constructor(e){super(e),this.name="UsageGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,y.prototype.constructor)}}function Qe(r,e){this.key=r,this.attributes=e,this.clear()}Qe.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.undirectedDegree=0,this.undirectedLoops=0,this.directedLoops=0,this.in={},this.out={},this.undirected={}};function Ze(r,e){this.key=r,this.attributes=e,this.clear()}Ze.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.directedLoops=0,this.in={},this.out={}};function et(r,e){this.key=r,this.attributes=e,this.clear()}et.prototype.clear=function(){this.undirectedDegree=0,this.undirectedLoops=0,this.undirected={}};function V(r,e,t,i,n){this.key=e,this.attributes=n,this.undirected=r,this.source=t,this.target=i}V.prototype.attach=function(){let r="out",e="in";this.undirected&&(r=e="undirected");const t=this.source.key,i=this.target.key;this.source[r][i]=this,!(this.undirected&&t===i)&&(this.target[e][t]=this)};V.prototype.attachMulti=function(){let r="out",e="in";const t=this.source.key,i=this.target.key;this.undirected&&(r=e="undirected");const n=this.source[r],o=n[i];if(typeof o>"u"){n[i]=this,this.undirected&&t===i||(this.target[e][t]=this);return}o.previous=this,this.next=o,n[i]=this,this.target[e][t]=this};V.prototype.detach=function(){const r=this.source.key,e=this.target.key;let t="out",i="in";this.undirected&&(t=i="undirected"),delete this.source[t][e],delete this.target[i][r]};V.prototype.detachMulti=function(){const r=this.source.key,e=this.target.key;let t="out",i="in";this.undirected&&(t=i="undirected"),this.previous===void 0?this.next===void 0?(delete this.source[t][e],delete this.target[i][r]):(this.next.previous=void 0,this.source[t][e]=this.next,this.target[i][r]=this.next):(this.previous.next=this.next,this.next!==void 0&&(this.next.previous=this.previous))};const tt=0,rt=1,Ht=2,it=3;function U(r,e,t,i,n,o,s){let a,d,u,h;if(i=""+i,t===tt){if(a=r._nodes.get(i),!a)throw new l(`Graph.${e}: could not find the "${i}" node in the graph.`);u=n,h=o}else if(t===it){if(n=""+n,d=r._edges.get(n),!d)throw new l(`Graph.${e}: could not find the "${n}" edge in the graph.`);const c=d.source.key,f=d.target.key;if(i===c)a=d.target;else if(i===f)a=d.source;else throw new l(`Graph.${e}: the "${i}" node is not attached to the "${n}" edge (${c}, ${f}).`);u=o,h=s}else{if(d=r._edges.get(i),!d)throw new l(`Graph.${e}: could not find the "${i}" edge in the graph.`);t===rt?a=d.source:a=d.target,u=n,h=o}return[a,u,h]}function Yt(r,e,t){r.prototype[e]=function(i,n,o){const[s,a]=U(this,e,t,i,n,o);return s.attributes[a]}}function Jt(r,e,t){r.prototype[e]=function(i,n){const[o]=U(this,e,t,i,n);return o.attributes}}function Xt(r,e,t){r.prototype[e]=function(i,n,o){const[s,a]=U(this,e,t,i,n,o);return s.attributes.hasOwnProperty(a)}}function Qt(r,e,t){r.prototype[e]=function(i,n,o,s){const[a,d,u]=U(this,e,t,i,n,o,s);return a.attributes[d]=u,this.emit("nodeAttributesUpdated",{key:a.key,type:"set",attributes:a.attributes,name:d}),this}}function Zt(r,e,t){r.prototype[e]=function(i,n,o,s){const[a,d,u]=U(this,e,t,i,n,o,s);if(typeof u!="function")throw new g(`Graph.${e}: updater should be a function.`);const h=a.attributes,c=u(h[d]);return h[d]=c,this.emit("nodeAttributesUpdated",{key:a.key,type:"set",attributes:a.attributes,name:d}),this}}function er(r,e,t){r.prototype[e]=function(i,n,o){const[s,a]=U(this,e,t,i,n,o);return delete s.attributes[a],this.emit("nodeAttributesUpdated",{key:s.key,type:"remove",attributes:s.attributes,name:a}),this}}function tr(r,e,t){r.prototype[e]=function(i,n,o){const[s,a]=U(this,e,t,i,n,o);if(!$(a))throw new g(`Graph.${e}: provided attributes are not a plain object.`);return s.attributes=a,this.emit("nodeAttributesUpdated",{key:s.key,type:"replace",attributes:s.attributes}),this}}function rr(r,e,t){r.prototype[e]=function(i,n,o){const[s,a]=U(this,e,t,i,n,o);if(!$(a))throw new g(`Graph.${e}: provided attributes are not a plain object.`);return k(s.attributes,a),this.emit("nodeAttributesUpdated",{key:s.key,type:"merge",attributes:s.attributes,data:a}),this}}function ir(r,e,t){r.prototype[e]=function(i,n,o){const[s,a]=U(this,e,t,i,n,o);if(typeof a!="function")throw new g(`Graph.${e}: provided updater is not a function.`);return s.attributes=a(s.attributes),this.emit("nodeAttributesUpdated",{key:s.key,type:"update",attributes:s.attributes}),this}}const nr=[{name:r=>`get${r}Attribute`,attacher:Yt},{name:r=>`get${r}Attributes`,attacher:Jt},{name:r=>`has${r}Attribute`,attacher:Xt},{name:r=>`set${r}Attribute`,attacher:Qt},{name:r=>`update${r}Attribute`,attacher:Zt},{name:r=>`remove${r}Attribute`,attacher:er},{name:r=>`replace${r}Attributes`,attacher:tr},{name:r=>`merge${r}Attributes`,attacher:rr},{name:r=>`update${r}Attributes`,attacher:ir}];function or(r){nr.forEach(function({name:e,attacher:t}){t(r,e("Node"),tt),t(r,e("Source"),rt),t(r,e("Target"),Ht),t(r,e("Opposite"),it)})}function sr(r,e,t){r.prototype[e]=function(i,n){let o;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new y(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new y(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const s=""+i,a=""+n;if(n=arguments[2],o=S(this,s,a,t),!o)throw new l(`Graph.${e}: could not find an edge for the given path ("${s}" - "${a}").`)}else{if(t!=="mixed")throw new y(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(i=""+i,o=this._edges.get(i),!o)throw new l(`Graph.${e}: could not find the "${i}" edge in the graph.`)}return o.attributes[n]}}function ar(r,e,t){r.prototype[e]=function(i){let n;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new y(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>1){if(this.multi)throw new y(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const o=""+i,s=""+arguments[1];if(n=S(this,o,s,t),!n)throw new l(`Graph.${e}: could not find an edge for the given path ("${o}" - "${s}").`)}else{if(t!=="mixed")throw new y(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(i=""+i,n=this._edges.get(i),!n)throw new l(`Graph.${e}: could not find the "${i}" edge in the graph.`)}return n.attributes}}function ur(r,e,t){r.prototype[e]=function(i,n){let o;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new y(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new y(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const s=""+i,a=""+n;if(n=arguments[2],o=S(this,s,a,t),!o)throw new l(`Graph.${e}: could not find an edge for the given path ("${s}" - "${a}").`)}else{if(t!=="mixed")throw new y(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(i=""+i,o=this._edges.get(i),!o)throw new l(`Graph.${e}: could not find the "${i}" edge in the graph.`)}return o.attributes.hasOwnProperty(n)}}function dr(r,e,t){r.prototype[e]=function(i,n,o){let s;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new y(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>3){if(this.multi)throw new y(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const a=""+i,d=""+n;if(n=arguments[2],o=arguments[3],s=S(this,a,d,t),!s)throw new l(`Graph.${e}: could not find an edge for the given path ("${a}" - "${d}").`)}else{if(t!=="mixed")throw new y(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(i=""+i,s=this._edges.get(i),!s)throw new l(`Graph.${e}: could not find the "${i}" edge in the graph.`)}return s.attributes[n]=o,this.emit("edgeAttributesUpdated",{key:s.key,type:"set",attributes:s.attributes,name:n}),this}}function cr(r,e,t){r.prototype[e]=function(i,n,o){let s;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new y(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>3){if(this.multi)throw new y(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const a=""+i,d=""+n;if(n=arguments[2],o=arguments[3],s=S(this,a,d,t),!s)throw new l(`Graph.${e}: could not find an edge for the given path ("${a}" - "${d}").`)}else{if(t!=="mixed")throw new y(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(i=""+i,s=this._edges.get(i),!s)throw new l(`Graph.${e}: could not find the "${i}" edge in the graph.`)}if(typeof o!="function")throw new g(`Graph.${e}: updater should be a function.`);return s.attributes[n]=o(s.attributes[n]),this.emit("edgeAttributesUpdated",{key:s.key,type:"set",attributes:s.attributes,name:n}),this}}function hr(r,e,t){r.prototype[e]=function(i,n){let o;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new y(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new y(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const s=""+i,a=""+n;if(n=arguments[2],o=S(this,s,a,t),!o)throw new l(`Graph.${e}: could not find an edge for the given path ("${s}" - "${a}").`)}else{if(t!=="mixed")throw new y(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(i=""+i,o=this._edges.get(i),!o)throw new l(`Graph.${e}: could not find the "${i}" edge in the graph.`)}return delete o.attributes[n],this.emit("edgeAttributesUpdated",{key:o.key,type:"remove",attributes:o.attributes,name:n}),this}}function fr(r,e,t){r.prototype[e]=function(i,n){let o;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new y(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new y(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const s=""+i,a=""+n;if(n=arguments[2],o=S(this,s,a,t),!o)throw new l(`Graph.${e}: could not find an edge for the given path ("${s}" - "${a}").`)}else{if(t!=="mixed")throw new y(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(i=""+i,o=this._edges.get(i),!o)throw new l(`Graph.${e}: could not find the "${i}" edge in the graph.`)}if(!$(n))throw new g(`Graph.${e}: provided attributes are not a plain object.`);return o.attributes=n,this.emit("edgeAttributesUpdated",{key:o.key,type:"replace",attributes:o.attributes}),this}}function lr(r,e,t){r.prototype[e]=function(i,n){let o;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new y(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new y(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const s=""+i,a=""+n;if(n=arguments[2],o=S(this,s,a,t),!o)throw new l(`Graph.${e}: could not find an edge for the given path ("${s}" - "${a}").`)}else{if(t!=="mixed")throw new y(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(i=""+i,o=this._edges.get(i),!o)throw new l(`Graph.${e}: could not find the "${i}" edge in the graph.`)}if(!$(n))throw new g(`Graph.${e}: provided attributes are not a plain object.`);return k(o.attributes,n),this.emit("edgeAttributesUpdated",{key:o.key,type:"merge",attributes:o.attributes,data:n}),this}}function pr(r,e,t){r.prototype[e]=function(i,n){let o;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new y(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new y(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const s=""+i,a=""+n;if(n=arguments[2],o=S(this,s,a,t),!o)throw new l(`Graph.${e}: could not find an edge for the given path ("${s}" - "${a}").`)}else{if(t!=="mixed")throw new y(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(i=""+i,o=this._edges.get(i),!o)throw new l(`Graph.${e}: could not find the "${i}" edge in the graph.`)}if(typeof n!="function")throw new g(`Graph.${e}: provided updater is not a function.`);return o.attributes=n(o.attributes),this.emit("edgeAttributesUpdated",{key:o.key,type:"update",attributes:o.attributes}),this}}const gr=[{name:r=>`get${r}Attribute`,attacher:sr},{name:r=>`get${r}Attributes`,attacher:ar},{name:r=>`has${r}Attribute`,attacher:ur},{name:r=>`set${r}Attribute`,attacher:dr},{name:r=>`update${r}Attribute`,attacher:cr},{name:r=>`remove${r}Attribute`,attacher:hr},{name:r=>`replace${r}Attributes`,attacher:fr},{name:r=>`merge${r}Attributes`,attacher:lr},{name:r=>`update${r}Attributes`,attacher:pr}];function yr(r){gr.forEach(function({name:e,attacher:t}){t(r,e("Edge"),"mixed"),t(r,e("DirectedEdge"),"directed"),t(r,e("UndirectedEdge"),"undirected")})}const mr=[{name:"edges",type:"mixed"},{name:"inEdges",type:"directed",direction:"in"},{name:"outEdges",type:"directed",direction:"out"},{name:"inboundEdges",type:"mixed",direction:"in"},{name:"outboundEdges",type:"mixed",direction:"out"},{name:"directedEdges",type:"directed"},{name:"undirectedEdges",type:"undirected"}];function wr(r,e,t,i){let n=!1;for(const o in e){if(o===i)continue;const s=e[o];if(n=t(s.key,s.attributes,s.source.key,s.target.key,s.source.attributes,s.target.attributes,s.undirected),r&&n)return s.key}}function br(r,e,t,i){let n,o,s,a=!1;for(const d in e)if(d!==i){n=e[d];do{if(o=n.source,s=n.target,a=t(n.key,n.attributes,o.key,s.key,o.attributes,s.attributes,n.undirected),r&&a)return n.key;n=n.next}while(n!==void 0)}}function de(r,e){const t=Object.keys(r),i=t.length;let n,o=0;return new G(function(){do if(n)n=n.next;else{if(o>=i)return{done:!0};const a=t[o++];if(a===e){n=void 0;continue}n=r[a]}while(!n);return{done:!1,value:{edge:n.key,attributes:n.attributes,source:n.source.key,target:n.target.key,sourceAttributes:n.source.attributes,targetAttributes:n.target.attributes,undirected:n.undirected}}})}function vr(r,e,t,i){const n=e[t];if(!n)return;const o=n.source,s=n.target;if(i(n.key,n.attributes,o.key,s.key,o.attributes,s.attributes,n.undirected)&&r)return n.key}function Er(r,e,t,i){let n=e[t];if(!n)return;let o=!1;do{if(o=i(n.key,n.attributes,n.source.key,n.target.key,n.source.attributes,n.target.attributes,n.undirected),r&&o)return n.key;n=n.next}while(n!==void 0)}function ce(r,e){let t=r[e];return t.next!==void 0?new G(function(){if(!t)return{done:!0};const i={edge:t.key,attributes:t.attributes,source:t.source.key,target:t.target.key,sourceAttributes:t.source.attributes,targetAttributes:t.target.attributes,undirected:t.undirected};return t=t.next,{done:!1,value:i}}):G.of({edge:t.key,attributes:t.attributes,source:t.source.key,target:t.target.key,sourceAttributes:t.source.attributes,targetAttributes:t.target.attributes,undirected:t.undirected})}function kr(r,e){if(r.size===0)return[];if(e==="mixed"||e===r.type)return typeof Array.from=="function"?Array.from(r._edges.keys()):Je(r._edges.keys(),r._edges.size);const t=e==="undirected"?r.undirectedSize:r.directedSize,i=new Array(t),n=e==="undirected",o=r._edges.values();let s=0,a,d;for(;a=o.next(),a.done!==!0;)d=a.value,d.undirected===n&&(i[s++]=d.key);return i}function nt(r,e,t,i){if(e.size===0)return;const n=t!=="mixed"&&t!==e.type,o=t==="undirected";let s,a,d=!1;const u=e._edges.values();for(;s=u.next(),s.done!==!0;){if(a=s.value,n&&a.undirected!==o)continue;const{key:h,attributes:c,source:f,target:p}=a;if(d=i(h,c,f.key,p.key,f.attributes,p.attributes,a.undirected),r&&d)return h}}function _r(r,e){if(r.size===0)return G.empty();const t=e!=="mixed"&&e!==r.type,i=e==="undirected",n=r._edges.values();return new G(function(){let s,a;for(;;){if(s=n.next(),s.done)return s;if(a=s.value,!(t&&a.undirected!==i))break}return{value:{edge:a.key,attributes:a.attributes,source:a.source.key,target:a.target.key,sourceAttributes:a.source.attributes,targetAttributes:a.target.attributes,undirected:a.undirected},done:!1}})}function be(r,e,t,i,n,o){const s=e?br:wr;let a;if(t!=="undirected"&&(i!=="out"&&(a=s(r,n.in,o),r&&a)||i!=="in"&&(a=s(r,n.out,o,i?void 0:n.key),r&&a))||t!=="directed"&&(a=s(r,n.undirected,o),r&&a))return a}function $r(r,e,t,i){const n=[];return be(!1,r,e,t,i,function(o){n.push(o)}),n}function xr(r,e,t){let i=G.empty();return r!=="undirected"&&(e!=="out"&&typeof t.in<"u"&&(i=C(i,de(t.in))),e!=="in"&&typeof t.out<"u"&&(i=C(i,de(t.out,e?void 0:t.key)))),r!=="directed"&&typeof t.undirected<"u"&&(i=C(i,de(t.undirected))),i}function ve(r,e,t,i,n,o,s){const a=t?Er:vr;let d;if(e!=="undirected"&&(typeof n.in<"u"&&i!=="out"&&(d=a(r,n.in,o,s),r&&d)||typeof n.out<"u"&&i!=="in"&&(i||n.key!==o)&&(d=a(r,n.out,o,s),r&&d))||e!=="directed"&&typeof n.undirected<"u"&&(d=a(r,n.undirected,o,s),r&&d))return d}function Ar(r,e,t,i,n){const o=[];return ve(!1,r,e,t,i,n,function(s){o.push(s)}),o}function Sr(r,e,t,i){let n=G.empty();return r!=="undirected"&&(typeof t.in<"u"&&e!=="out"&&i in t.in&&(n=C(n,ce(t.in,i))),typeof t.out<"u"&&e!=="in"&&i in t.out&&(e||t.key!==i)&&(n=C(n,ce(t.out,i)))),r!=="directed"&&typeof t.undirected<"u"&&i in t.undirected&&(n=C(n,ce(t.undirected,i))),n}function Gr(r,e){const{name:t,type:i,direction:n}=e;r.prototype[t]=function(o,s){if(i!=="mixed"&&this.type!=="mixed"&&i!==this.type)return[];if(!arguments.length)return kr(this,i);if(arguments.length===1){o=""+o;const a=this._nodes.get(o);if(typeof a>"u")throw new l(`Graph.${t}: could not find the "${o}" node in the graph.`);return $r(this.multi,i==="mixed"?this.type:i,n,a)}if(arguments.length===2){o=""+o,s=""+s;const a=this._nodes.get(o);if(!a)throw new l(`Graph.${t}:  could not find the "${o}" source node in the graph.`);if(!this._nodes.has(s))throw new l(`Graph.${t}:  could not find the "${s}" target node in the graph.`);return Ar(i,this.multi,n,a,s)}throw new g(`Graph.${t}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`)}}function Nr(r,e){const{name:t,type:i,direction:n}=e,o="forEach"+t[0].toUpperCase()+t.slice(1,-1);r.prototype[o]=function(u,h,c){if(!(i!=="mixed"&&this.type!=="mixed"&&i!==this.type)){if(arguments.length===1)return c=u,nt(!1,this,i,c);if(arguments.length===2){u=""+u,c=h;const f=this._nodes.get(u);if(typeof f>"u")throw new l(`Graph.${o}: could not find the "${u}" node in the graph.`);return be(!1,this.multi,i==="mixed"?this.type:i,n,f,c)}if(arguments.length===3){u=""+u,h=""+h;const f=this._nodes.get(u);if(!f)throw new l(`Graph.${o}:  could not find the "${u}" source node in the graph.`);if(!this._nodes.has(h))throw new l(`Graph.${o}:  could not find the "${h}" target node in the graph.`);return ve(!1,i,this.multi,n,f,h,c)}throw new g(`Graph.${o}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`)}};const s="map"+t[0].toUpperCase()+t.slice(1);r.prototype[s]=function(){const u=Array.prototype.slice.call(arguments),h=u.pop();let c;if(u.length===0){let f=0;i!=="directed"&&(f+=this.undirectedSize),i!=="undirected"&&(f+=this.directedSize),c=new Array(f);let p=0;u.push((w,m,E,_,x,j,X)=>{c[p++]=h(w,m,E,_,x,j,X)})}else c=[],u.push((f,p,w,m,E,_,x)=>{c.push(h(f,p,w,m,E,_,x))});return this[o].apply(this,u),c};const a="filter"+t[0].toUpperCase()+t.slice(1);r.prototype[a]=function(){const u=Array.prototype.slice.call(arguments),h=u.pop(),c=[];return u.push((f,p,w,m,E,_,x)=>{h(f,p,w,m,E,_,x)&&c.push(f)}),this[o].apply(this,u),c};const d="reduce"+t[0].toUpperCase()+t.slice(1);r.prototype[d]=function(){let u=Array.prototype.slice.call(arguments);if(u.length<2||u.length>4)throw new g(`Graph.${d}: invalid number of arguments (expecting 2, 3 or 4 and got ${u.length}).`);if(typeof u[u.length-1]=="function"&&typeof u[u.length-2]!="function")throw new g(`Graph.${d}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`);let h,c;u.length===2?(h=u[0],c=u[1],u=[]):u.length===3?(h=u[1],c=u[2],u=[u[0]]):u.length===4&&(h=u[2],c=u[3],u=[u[0],u[1]]);let f=c;return u.push((p,w,m,E,_,x,j)=>{f=h(f,p,w,m,E,_,x,j)}),this[o].apply(this,u),f}}function Dr(r,e){const{name:t,type:i,direction:n}=e,o="find"+t[0].toUpperCase()+t.slice(1,-1);r.prototype[o]=function(d,u,h){if(i!=="mixed"&&this.type!=="mixed"&&i!==this.type)return!1;if(arguments.length===1)return h=d,nt(!0,this,i,h);if(arguments.length===2){d=""+d,h=u;const c=this._nodes.get(d);if(typeof c>"u")throw new l(`Graph.${o}: could not find the "${d}" node in the graph.`);return be(!0,this.multi,i==="mixed"?this.type:i,n,c,h)}if(arguments.length===3){d=""+d,u=""+u;const c=this._nodes.get(d);if(!c)throw new l(`Graph.${o}:  could not find the "${d}" source node in the graph.`);if(!this._nodes.has(u))throw new l(`Graph.${o}:  could not find the "${u}" target node in the graph.`);return ve(!0,i,this.multi,n,c,u,h)}throw new g(`Graph.${o}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`)};const s="some"+t[0].toUpperCase()+t.slice(1,-1);r.prototype[s]=function(){const d=Array.prototype.slice.call(arguments),u=d.pop();return d.push((c,f,p,w,m,E,_)=>u(c,f,p,w,m,E,_)),!!this[o].apply(this,d)};const a="every"+t[0].toUpperCase()+t.slice(1,-1);r.prototype[a]=function(){const d=Array.prototype.slice.call(arguments),u=d.pop();return d.push((c,f,p,w,m,E,_)=>!u(c,f,p,w,m,E,_)),!this[o].apply(this,d)}}function Lr(r,e){const{name:t,type:i,direction:n}=e,o=t.slice(0,-1)+"Entries";r.prototype[o]=function(s,a){if(i!=="mixed"&&this.type!=="mixed"&&i!==this.type)return G.empty();if(!arguments.length)return _r(this,i);if(arguments.length===1){s=""+s;const d=this._nodes.get(s);if(!d)throw new l(`Graph.${o}: could not find the "${s}" node in the graph.`);return xr(i,n,d)}if(arguments.length===2){s=""+s,a=""+a;const d=this._nodes.get(s);if(!d)throw new l(`Graph.${o}:  could not find the "${s}" source node in the graph.`);if(!this._nodes.has(a))throw new l(`Graph.${o}:  could not find the "${a}" target node in the graph.`);return Sr(i,n,d,a)}throw new g(`Graph.${o}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`)}}function Cr(r){mr.forEach(e=>{Gr(r,e),Nr(r,e),Dr(r,e),Lr(r,e)})}const Or=[{name:"neighbors",type:"mixed"},{name:"inNeighbors",type:"directed",direction:"in"},{name:"outNeighbors",type:"directed",direction:"out"},{name:"inboundNeighbors",type:"mixed",direction:"in"},{name:"outboundNeighbors",type:"mixed",direction:"out"},{name:"directedNeighbors",type:"directed"},{name:"undirectedNeighbors",type:"undirected"}];function se(){this.A=null,this.B=null}se.prototype.wrap=function(r){this.A===null?this.A=r:this.B===null&&(this.B=r)};se.prototype.has=function(r){return this.A!==null&&r in this.A||this.B!==null&&r in this.B};function q(r,e,t,i,n){for(const o in i){const s=i[o],a=s.source,d=s.target,u=a===t?d:a;if(e&&e.has(u.key))continue;const h=n(u.key,u.attributes);if(r&&h)return u.key}}function Ee(r,e,t,i,n){if(e!=="mixed"){if(e==="undirected")return q(r,null,i,i.undirected,n);if(typeof t=="string")return q(r,null,i,i[t],n)}const o=new se;let s;if(e!=="undirected"){if(t!=="out"){if(s=q(r,null,i,i.in,n),r&&s)return s;o.wrap(i.in)}if(t!=="in"){if(s=q(r,o,i,i.out,n),r&&s)return s;o.wrap(i.out)}}if(e!=="directed"&&(s=q(r,o,i,i.undirected,n),r&&s))return s}function Ur(r,e,t){if(r!=="mixed"){if(r==="undirected")return Object.keys(t.undirected);if(typeof e=="string")return Object.keys(t[e])}const i=[];return Ee(!1,r,e,t,function(n){i.push(n)}),i}function H(r,e,t){const i=Object.keys(t),n=i.length;let o=0;return new G(function(){let a=null;do{if(o>=n)return r&&r.wrap(t),{done:!0};const d=t[i[o++]],u=d.source,h=d.target;if(a=u===e?h:u,r&&r.has(a.key)){a=null;continue}}while(a===null);return{done:!1,value:{neighbor:a.key,attributes:a.attributes}}})}function jr(r,e,t){if(r!=="mixed"){if(r==="undirected")return H(null,t,t.undirected);if(typeof e=="string")return H(null,t,t[e])}let i=G.empty();const n=new se;return r!=="undirected"&&(e!=="out"&&(i=C(i,H(n,t,t.in))),e!=="in"&&(i=C(i,H(n,t,t.out)))),r!=="directed"&&(i=C(i,H(n,t,t.undirected))),i}function Ir(r,e){const{name:t,type:i,direction:n}=e;r.prototype[t]=function(o){if(i!=="mixed"&&this.type!=="mixed"&&i!==this.type)return[];o=""+o;const s=this._nodes.get(o);if(typeof s>"u")throw new l(`Graph.${t}: could not find the "${o}" node in the graph.`);return Ur(i==="mixed"?this.type:i,n,s)}}function Tr(r,e){const{name:t,type:i,direction:n}=e,o="forEach"+t[0].toUpperCase()+t.slice(1,-1);r.prototype[o]=function(u,h){if(i!=="mixed"&&this.type!=="mixed"&&i!==this.type)return;u=""+u;const c=this._nodes.get(u);if(typeof c>"u")throw new l(`Graph.${o}: could not find the "${u}" node in the graph.`);Ee(!1,i==="mixed"?this.type:i,n,c,h)};const s="map"+t[0].toUpperCase()+t.slice(1);r.prototype[s]=function(u,h){const c=[];return this[o](u,(f,p)=>{c.push(h(f,p))}),c};const a="filter"+t[0].toUpperCase()+t.slice(1);r.prototype[a]=function(u,h){const c=[];return this[o](u,(f,p)=>{h(f,p)&&c.push(f)}),c};const d="reduce"+t[0].toUpperCase()+t.slice(1);r.prototype[d]=function(u,h,c){if(arguments.length<3)throw new g(`Graph.${d}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`);let f=c;return this[o](u,(p,w)=>{f=h(f,p,w)}),f}}function zr(r,e){const{name:t,type:i,direction:n}=e,o=t[0].toUpperCase()+t.slice(1,-1),s="find"+o;r.prototype[s]=function(u,h){if(i!=="mixed"&&this.type!=="mixed"&&i!==this.type)return;u=""+u;const c=this._nodes.get(u);if(typeof c>"u")throw new l(`Graph.${s}: could not find the "${u}" node in the graph.`);return Ee(!0,i==="mixed"?this.type:i,n,c,h)};const a="some"+o;r.prototype[a]=function(u,h){return!!this[s](u,h)};const d="every"+o;r.prototype[d]=function(u,h){return!this[s](u,(f,p)=>!h(f,p))}}function Pr(r,e){const{name:t,type:i,direction:n}=e,o=t.slice(0,-1)+"Entries";r.prototype[o]=function(s){if(i!=="mixed"&&this.type!=="mixed"&&i!==this.type)return G.empty();s=""+s;const a=this._nodes.get(s);if(typeof a>"u")throw new l(`Graph.${o}: could not find the "${s}" node in the graph.`);return jr(i==="mixed"?this.type:i,n,a)}}function Mr(r){Or.forEach(e=>{Ir(r,e),Tr(r,e),zr(r,e),Pr(r,e)})}function Z(r,e,t,i,n){const o=i._nodes.values(),s=i.type;let a,d,u,h,c,f,p;for(;a=o.next(),a.done!==!0;){let w=!1;if(d=a.value,s!=="undirected"){h=d.out;for(u in h){c=h[u];do{if(f=c.target,w=!0,p=n(d.key,f.key,d.attributes,f.attributes,c.key,c.attributes,c.undirected),r&&p)return c;c=c.next}while(c)}}if(s!=="directed"){h=d.undirected;for(u in h)if(!(e&&d.key>u)){c=h[u];do{if(f=c.target,f.key!==u&&(f=c.source),w=!0,p=n(d.key,f.key,d.attributes,f.attributes,c.key,c.attributes,c.undirected),r&&p)return c;c=c.next}while(c)}}if(t&&!w&&(p=n(d.key,null,d.attributes,null,null,null,null),r&&p))return null}}function Rr(r,e){const t={key:r};return Xe(e.attributes)||(t.attributes=k({},e.attributes)),t}function Fr(r,e,t){const i={key:e,source:t.source.key,target:t.target.key};return Xe(t.attributes)||(i.attributes=k({},t.attributes)),r==="mixed"&&t.undirected&&(i.undirected=!0),i}function Wr(r){if(!$(r))throw new g('Graph.import: invalid serialized node. A serialized node should be a plain object with at least a "key" property.');if(!("key"in r))throw new g("Graph.import: serialized node is missing its key.");if("attributes"in r&&(!$(r.attributes)||r.attributes===null))throw new g("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.")}function Kr(r){if(!$(r))throw new g('Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a "source" & "target" property.');if(!("source"in r))throw new g("Graph.import: serialized edge is missing its source.");if(!("target"in r))throw new g("Graph.import: serialized edge is missing its target.");if("attributes"in r&&(!$(r.attributes)||r.attributes===null))throw new g("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.");if("undirected"in r&&typeof r.undirected!="boolean")throw new g("Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.")}const Vr=qt(),Br=new Set(["directed","undirected","mixed"]),De=new Set(["domain","_events","_eventsCount","_maxListeners"]),qr=[{name:r=>`${r}Edge`,generateKey:!0},{name:r=>`${r}DirectedEdge`,generateKey:!0,type:"directed"},{name:r=>`${r}UndirectedEdge`,generateKey:!0,type:"undirected"},{name:r=>`${r}EdgeWithKey`},{name:r=>`${r}DirectedEdgeWithKey`,type:"directed"},{name:r=>`${r}UndirectedEdgeWithKey`,type:"undirected"}],Hr={allowSelfLoops:!0,multi:!1,type:"mixed"};function Yr(r,e,t){if(t&&!$(t))throw new g(`Graph.addNode: invalid attributes. Expecting an object but got "${t}"`);if(e=""+e,t=t||{},r._nodes.has(e))throw new y(`Graph.addNode: the "${e}" node already exist in the graph.`);const i=new r.NodeDataClass(e,t);return r._nodes.set(e,i),r.emit("nodeAdded",{key:e,attributes:t}),i}function Le(r,e,t){const i=new r.NodeDataClass(e,t);return r._nodes.set(e,i),r.emit("nodeAdded",{key:e,attributes:t}),i}function ot(r,e,t,i,n,o,s,a){if(!i&&r.type==="undirected")throw new y(`Graph.${e}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`);if(i&&r.type==="directed")throw new y(`Graph.${e}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`);if(a&&!$(a))throw new g(`Graph.${e}: invalid attributes. Expecting an object but got "${a}"`);if(o=""+o,s=""+s,a=a||{},!r.allowSelfLoops&&o===s)throw new y(`Graph.${e}: source & target are the same ("${o}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);const d=r._nodes.get(o),u=r._nodes.get(s);if(!d)throw new l(`Graph.${e}: source node "${o}" not found.`);if(!u)throw new l(`Graph.${e}: target node "${s}" not found.`);const h={key:null,undirected:i,source:o,target:s,attributes:a};if(t)n=r._edgeKeyGenerator();else if(n=""+n,r._edges.has(n))throw new y(`Graph.${e}: the "${n}" edge already exists in the graph.`);if(!r.multi&&(i?typeof d.undirected[s]<"u":typeof d.out[s]<"u"))throw new y(`Graph.${e}: an edge linking "${o}" to "${s}" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`);const c=new V(i,n,d,u,a);r._edges.set(n,c);const f=o===s;return i?(d.undirectedDegree++,u.undirectedDegree++,f&&(d.undirectedLoops++,r._undirectedSelfLoopCount++)):(d.outDegree++,u.inDegree++,f&&(d.directedLoops++,r._directedSelfLoopCount++)),r.multi?c.attachMulti():c.attach(),i?r._undirectedSize++:r._directedSize++,h.key=n,r.emit("edgeAdded",h),n}function Jr(r,e,t,i,n,o,s,a,d){if(!i&&r.type==="undirected")throw new y(`Graph.${e}: you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead.`);if(i&&r.type==="directed")throw new y(`Graph.${e}: you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead.`);if(a){if(d){if(typeof a!="function")throw new g(`Graph.${e}: invalid updater function. Expecting a function but got "${a}"`)}else if(!$(a))throw new g(`Graph.${e}: invalid attributes. Expecting an object but got "${a}"`)}o=""+o,s=""+s;let u;if(d&&(u=a,a=void 0),!r.allowSelfLoops&&o===s)throw new y(`Graph.${e}: source & target are the same ("${o}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);let h=r._nodes.get(o),c=r._nodes.get(s),f,p;if(!t&&(f=r._edges.get(n),f)){if((f.source.key!==o||f.target.key!==s)&&(!i||f.source.key!==s||f.target.key!==o))throw new y(`Graph.${e}: inconsistency detected when attempting to merge the "${n}" edge with "${o}" source & "${s}" target vs. ("${f.source.key}", "${f.target.key}").`);p=f}if(!p&&!r.multi&&h&&(p=i?h.undirected[s]:h.out[s]),p){const x=[p.key,!1,!1,!1];if(d?!u:!a)return x;if(d){const j=p.attributes;p.attributes=u(j),r.emit("edgeAttributesUpdated",{type:"replace",key:p.key,attributes:p.attributes})}else k(p.attributes,a),r.emit("edgeAttributesUpdated",{type:"merge",key:p.key,attributes:p.attributes,data:a});return x}a=a||{},d&&u&&(a=u(a));const w={key:null,undirected:i,source:o,target:s,attributes:a};if(t)n=r._edgeKeyGenerator();else if(n=""+n,r._edges.has(n))throw new y(`Graph.${e}: the "${n}" edge already exists in the graph.`);let m=!1,E=!1;h||(h=Le(r,o,{}),m=!0,o===s&&(c=h,E=!0)),c||(c=Le(r,s,{}),E=!0),f=new V(i,n,h,c,a),r._edges.set(n,f);const _=o===s;return i?(h.undirectedDegree++,c.undirectedDegree++,_&&(h.undirectedLoops++,r._undirectedSelfLoopCount++)):(h.outDegree++,c.inDegree++,_&&(h.directedLoops++,r._directedSelfLoopCount++)),r.multi?f.attachMulti():f.attach(),i?r._undirectedSize++:r._directedSize++,w.key=n,r.emit("edgeAdded",w),[n,!0,m,E]}function M(r,e){r._edges.delete(e.key);const{source:t,target:i,attributes:n}=e,o=e.undirected,s=t===i;o?(t.undirectedDegree--,i.undirectedDegree--,s&&(t.undirectedLoops--,r._undirectedSelfLoopCount--)):(t.outDegree--,i.inDegree--,s&&(t.directedLoops--,r._directedSelfLoopCount--)),r.multi?e.detachMulti():e.detach(),o?r._undirectedSize--:r._directedSize--,r.emit("edgeDropped",{key:e.key,attributes:n,source:t.key,target:i.key,undirected:o})}class v extends It.EventEmitter{constructor(e){if(super(),e=k({},Hr,e),typeof e.multi!="boolean")throw new g(`Graph.constructor: invalid 'multi' option. Expecting a boolean but got "${e.multi}".`);if(!Br.has(e.type))throw new g(`Graph.constructor: invalid 'type' option. Should be one of "mixed", "directed" or "undirected" but got "${e.type}".`);if(typeof e.allowSelfLoops!="boolean")throw new g(`Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got "${e.allowSelfLoops}".`);const t=e.type==="mixed"?Qe:e.type==="directed"?Ze:et;A(this,"NodeDataClass",t);const i="geid_"+Vr()+"_";let n=0;const o=()=>{let s;do s=i+n++;while(this._edges.has(s));return s};A(this,"_attributes",{}),A(this,"_nodes",new Map),A(this,"_edges",new Map),A(this,"_directedSize",0),A(this,"_undirectedSize",0),A(this,"_directedSelfLoopCount",0),A(this,"_undirectedSelfLoopCount",0),A(this,"_edgeKeyGenerator",o),A(this,"_options",e),De.forEach(s=>A(this,s,this[s])),N(this,"order",()=>this._nodes.size),N(this,"size",()=>this._edges.size),N(this,"directedSize",()=>this._directedSize),N(this,"undirectedSize",()=>this._undirectedSize),N(this,"selfLoopCount",()=>this._directedSelfLoopCount+this._undirectedSelfLoopCount),N(this,"directedSelfLoopCount",()=>this._directedSelfLoopCount),N(this,"undirectedSelfLoopCount",()=>this._undirectedSelfLoopCount),N(this,"multi",this._options.multi),N(this,"type",this._options.type),N(this,"allowSelfLoops",this._options.allowSelfLoops),N(this,"implementation",()=>"graphology")}_resetInstanceCounters(){this._directedSize=0,this._undirectedSize=0,this._directedSelfLoopCount=0,this._undirectedSelfLoopCount=0}hasNode(e){return this._nodes.has(""+e)}hasDirectedEdge(e,t){if(this.type==="undirected")return!1;if(arguments.length===1){const i=""+e,n=this._edges.get(i);return!!n&&!n.undirected}else if(arguments.length===2){e=""+e,t=""+t;const i=this._nodes.get(e);return i?i.out.hasOwnProperty(t):!1}throw new g(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}hasUndirectedEdge(e,t){if(this.type==="directed")return!1;if(arguments.length===1){const i=""+e,n=this._edges.get(i);return!!n&&n.undirected}else if(arguments.length===2){e=""+e,t=""+t;const i=this._nodes.get(e);return i?i.undirected.hasOwnProperty(t):!1}throw new g(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}hasEdge(e,t){if(arguments.length===1){const i=""+e;return this._edges.has(i)}else if(arguments.length===2){e=""+e,t=""+t;const i=this._nodes.get(e);return i?typeof i.out<"u"&&i.out.hasOwnProperty(t)||typeof i.undirected<"u"&&i.undirected.hasOwnProperty(t):!1}throw new g(`Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}directedEdge(e,t){if(this.type==="undirected")return;if(e=""+e,t=""+t,this.multi)throw new y("Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.");const i=this._nodes.get(e);if(!i)throw new l(`Graph.directedEdge: could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new l(`Graph.directedEdge: could not find the "${t}" target node in the graph.`);const n=i.out&&i.out[t]||void 0;if(n)return n.key}undirectedEdge(e,t){if(this.type==="directed")return;if(e=""+e,t=""+t,this.multi)throw new y("Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.");const i=this._nodes.get(e);if(!i)throw new l(`Graph.undirectedEdge: could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new l(`Graph.undirectedEdge: could not find the "${t}" target node in the graph.`);const n=i.undirected&&i.undirected[t]||void 0;if(n)return n.key}edge(e,t){if(this.multi)throw new y("Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.");e=""+e,t=""+t;const i=this._nodes.get(e);if(!i)throw new l(`Graph.edge: could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new l(`Graph.edge: could not find the "${t}" target node in the graph.`);const n=i.out&&i.out[t]||i.undirected&&i.undirected[t]||void 0;if(n)return n.key}areDirectedNeighbors(e,t){e=""+e,t=""+t;const i=this._nodes.get(e);if(!i)throw new l(`Graph.areDirectedNeighbors: could not find the "${e}" node in the graph.`);return this.type==="undirected"?!1:t in i.in||t in i.out}areOutNeighbors(e,t){e=""+e,t=""+t;const i=this._nodes.get(e);if(!i)throw new l(`Graph.areOutNeighbors: could not find the "${e}" node in the graph.`);return this.type==="undirected"?!1:t in i.out}areInNeighbors(e,t){e=""+e,t=""+t;const i=this._nodes.get(e);if(!i)throw new l(`Graph.areInNeighbors: could not find the "${e}" node in the graph.`);return this.type==="undirected"?!1:t in i.in}areUndirectedNeighbors(e,t){e=""+e,t=""+t;const i=this._nodes.get(e);if(!i)throw new l(`Graph.areUndirectedNeighbors: could not find the "${e}" node in the graph.`);return this.type==="directed"?!1:t in i.undirected}areNeighbors(e,t){e=""+e,t=""+t;const i=this._nodes.get(e);if(!i)throw new l(`Graph.areNeighbors: could not find the "${e}" node in the graph.`);return this.type!=="undirected"&&(t in i.in||t in i.out)||this.type!=="directed"&&t in i.undirected}areInboundNeighbors(e,t){e=""+e,t=""+t;const i=this._nodes.get(e);if(!i)throw new l(`Graph.areInboundNeighbors: could not find the "${e}" node in the graph.`);return this.type!=="undirected"&&t in i.in||this.type!=="directed"&&t in i.undirected}areOutboundNeighbors(e,t){e=""+e,t=""+t;const i=this._nodes.get(e);if(!i)throw new l(`Graph.areOutboundNeighbors: could not find the "${e}" node in the graph.`);return this.type!=="undirected"&&t in i.out||this.type!=="directed"&&t in i.undirected}inDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new l(`Graph.inDegree: could not find the "${e}" node in the graph.`);return this.type==="undirected"?0:t.inDegree}outDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new l(`Graph.outDegree: could not find the "${e}" node in the graph.`);return this.type==="undirected"?0:t.outDegree}directedDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new l(`Graph.directedDegree: could not find the "${e}" node in the graph.`);return this.type==="undirected"?0:t.inDegree+t.outDegree}undirectedDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new l(`Graph.undirectedDegree: could not find the "${e}" node in the graph.`);return this.type==="directed"?0:t.undirectedDegree}inboundDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new l(`Graph.inboundDegree: could not find the "${e}" node in the graph.`);let i=0;return this.type!=="directed"&&(i+=t.undirectedDegree),this.type!=="undirected"&&(i+=t.inDegree),i}outboundDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new l(`Graph.outboundDegree: could not find the "${e}" node in the graph.`);let i=0;return this.type!=="directed"&&(i+=t.undirectedDegree),this.type!=="undirected"&&(i+=t.outDegree),i}degree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new l(`Graph.degree: could not find the "${e}" node in the graph.`);let i=0;return this.type!=="directed"&&(i+=t.undirectedDegree),this.type!=="undirected"&&(i+=t.inDegree+t.outDegree),i}inDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new l(`Graph.inDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);return this.type==="undirected"?0:t.inDegree-t.directedLoops}outDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new l(`Graph.outDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);return this.type==="undirected"?0:t.outDegree-t.directedLoops}directedDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new l(`Graph.directedDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);return this.type==="undirected"?0:t.inDegree+t.outDegree-t.directedLoops*2}undirectedDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new l(`Graph.undirectedDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);return this.type==="directed"?0:t.undirectedDegree-t.undirectedLoops*2}inboundDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new l(`Graph.inboundDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);let i=0,n=0;return this.type!=="directed"&&(i+=t.undirectedDegree,n+=t.undirectedLoops*2),this.type!=="undirected"&&(i+=t.inDegree,n+=t.directedLoops),i-n}outboundDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new l(`Graph.outboundDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);let i=0,n=0;return this.type!=="directed"&&(i+=t.undirectedDegree,n+=t.undirectedLoops*2),this.type!=="undirected"&&(i+=t.outDegree,n+=t.directedLoops),i-n}degreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new l(`Graph.degreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);let i=0,n=0;return this.type!=="directed"&&(i+=t.undirectedDegree,n+=t.undirectedLoops*2),this.type!=="undirected"&&(i+=t.inDegree+t.outDegree,n+=t.directedLoops*2),i-n}source(e){e=""+e;const t=this._edges.get(e);if(!t)throw new l(`Graph.source: could not find the "${e}" edge in the graph.`);return t.source.key}target(e){e=""+e;const t=this._edges.get(e);if(!t)throw new l(`Graph.target: could not find the "${e}" edge in the graph.`);return t.target.key}extremities(e){e=""+e;const t=this._edges.get(e);if(!t)throw new l(`Graph.extremities: could not find the "${e}" edge in the graph.`);return[t.source.key,t.target.key]}opposite(e,t){e=""+e,t=""+t;const i=this._edges.get(t);if(!i)throw new l(`Graph.opposite: could not find the "${t}" edge in the graph.`);const n=i.source.key,o=i.target.key;if(e===n)return o;if(e===o)return n;throw new l(`Graph.opposite: the "${e}" node is not attached to the "${t}" edge (${n}, ${o}).`)}hasExtremity(e,t){e=""+e,t=""+t;const i=this._edges.get(e);if(!i)throw new l(`Graph.hasExtremity: could not find the "${e}" edge in the graph.`);return i.source.key===t||i.target.key===t}isUndirected(e){e=""+e;const t=this._edges.get(e);if(!t)throw new l(`Graph.isUndirected: could not find the "${e}" edge in the graph.`);return t.undirected}isDirected(e){e=""+e;const t=this._edges.get(e);if(!t)throw new l(`Graph.isDirected: could not find the "${e}" edge in the graph.`);return!t.undirected}isSelfLoop(e){e=""+e;const t=this._edges.get(e);if(!t)throw new l(`Graph.isSelfLoop: could not find the "${e}" edge in the graph.`);return t.source===t.target}addNode(e,t){return Yr(this,e,t).key}mergeNode(e,t){if(t&&!$(t))throw new g(`Graph.mergeNode: invalid attributes. Expecting an object but got "${t}"`);e=""+e,t=t||{};let i=this._nodes.get(e);return i?(t&&(k(i.attributes,t),this.emit("nodeAttributesUpdated",{type:"merge",key:e,attributes:i.attributes,data:t})),[e,!1]):(i=new this.NodeDataClass(e,t),this._nodes.set(e,i),this.emit("nodeAdded",{key:e,attributes:t}),[e,!0])}updateNode(e,t){if(t&&typeof t!="function")throw new g(`Graph.updateNode: invalid updater function. Expecting a function but got "${t}"`);e=""+e;let i=this._nodes.get(e);if(i){if(t){const o=i.attributes;i.attributes=t(o),this.emit("nodeAttributesUpdated",{type:"replace",key:e,attributes:i.attributes})}return[e,!1]}const n=t?t({}):{};return i=new this.NodeDataClass(e,n),this._nodes.set(e,i),this.emit("nodeAdded",{key:e,attributes:n}),[e,!0]}dropNode(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new l(`Graph.dropNode: could not find the "${e}" node in the graph.`);let i;if(this.type!=="undirected"){for(const n in t.out){i=t.out[n];do M(this,i),i=i.next;while(i)}for(const n in t.in){i=t.in[n];do M(this,i),i=i.next;while(i)}}if(this.type!=="directed")for(const n in t.undirected){i=t.undirected[n];do M(this,i),i=i.next;while(i)}this._nodes.delete(e),this.emit("nodeDropped",{key:e,attributes:t.attributes})}dropEdge(e){let t;if(arguments.length>1){const i=""+arguments[0],n=""+arguments[1];if(t=S(this,i,n,this.type),!t)throw new l(`Graph.dropEdge: could not find the "${i}" -> "${n}" edge in the graph.`)}else if(e=""+e,t=this._edges.get(e),!t)throw new l(`Graph.dropEdge: could not find the "${e}" edge in the graph.`);return M(this,t),this}dropDirectedEdge(e,t){if(arguments.length<2)throw new y("Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new y("Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");e=""+e,t=""+t;const i=S(this,e,t,"directed");if(!i)throw new l(`Graph.dropDirectedEdge: could not find a "${e}" -> "${t}" edge in the graph.`);return M(this,i),this}dropUndirectedEdge(e,t){if(arguments.length<2)throw new y("Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new y("Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");const i=S(this,e,t,"undirected");if(!i)throw new l(`Graph.dropUndirectedEdge: could not find a "${e}" -> "${t}" edge in the graph.`);return M(this,i),this}clear(){this._edges.clear(),this._nodes.clear(),this._resetInstanceCounters(),this.emit("cleared")}clearEdges(){const e=this._nodes.values();let t;for(;t=e.next(),t.done!==!0;)t.value.clear();this._edges.clear(),this._resetInstanceCounters(),this.emit("edgesCleared")}getAttribute(e){return this._attributes[e]}getAttributes(){return this._attributes}hasAttribute(e){return this._attributes.hasOwnProperty(e)}setAttribute(e,t){return this._attributes[e]=t,this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:e}),this}updateAttribute(e,t){if(typeof t!="function")throw new g("Graph.updateAttribute: updater should be a function.");const i=this._attributes[e];return this._attributes[e]=t(i),this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:e}),this}removeAttribute(e){return delete this._attributes[e],this.emit("attributesUpdated",{type:"remove",attributes:this._attributes,name:e}),this}replaceAttributes(e){if(!$(e))throw new g("Graph.replaceAttributes: provided attributes are not a plain object.");return this._attributes=e,this.emit("attributesUpdated",{type:"replace",attributes:this._attributes}),this}mergeAttributes(e){if(!$(e))throw new g("Graph.mergeAttributes: provided attributes are not a plain object.");return k(this._attributes,e),this.emit("attributesUpdated",{type:"merge",attributes:this._attributes,data:e}),this}updateAttributes(e){if(typeof e!="function")throw new g("Graph.updateAttributes: provided updater is not a function.");return this._attributes=e(this._attributes),this.emit("attributesUpdated",{type:"update",attributes:this._attributes}),this}updateEachNodeAttributes(e,t){if(typeof e!="function")throw new g("Graph.updateEachNodeAttributes: expecting an updater function.");if(t&&!Ne(t))throw new g("Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");const i=this._nodes.values();let n,o;for(;n=i.next(),n.done!==!0;)o=n.value,o.attributes=e(o.key,o.attributes);this.emit("eachNodeAttributesUpdated",{hints:t||null})}updateEachEdgeAttributes(e,t){if(typeof e!="function")throw new g("Graph.updateEachEdgeAttributes: expecting an updater function.");if(t&&!Ne(t))throw new g("Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");const i=this._edges.values();let n,o,s,a;for(;n=i.next(),n.done!==!0;)o=n.value,s=o.source,a=o.target,o.attributes=e(o.key,o.attributes,s.key,a.key,s.attributes,a.attributes,o.undirected);this.emit("eachEdgeAttributesUpdated",{hints:t||null})}forEachAdjacencyEntry(e){if(typeof e!="function")throw new g("Graph.forEachAdjacencyEntry: expecting a callback.");Z(!1,!1,!1,this,e)}forEachAdjacencyEntryWithOrphans(e){if(typeof e!="function")throw new g("Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.");Z(!1,!1,!0,this,e)}forEachAssymetricAdjacencyEntry(e){if(typeof e!="function")throw new g("Graph.forEachAssymetricAdjacencyEntry: expecting a callback.");Z(!1,!0,!1,this,e)}forEachAssymetricAdjacencyEntryWithOrphans(e){if(typeof e!="function")throw new g("Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.");Z(!1,!0,!0,this,e)}nodes(){return typeof Array.from=="function"?Array.from(this._nodes.keys()):Je(this._nodes.keys(),this._nodes.size)}forEachNode(e){if(typeof e!="function")throw new g("Graph.forEachNode: expecting a callback.");const t=this._nodes.values();let i,n;for(;i=t.next(),i.done!==!0;)n=i.value,e(n.key,n.attributes)}findNode(e){if(typeof e!="function")throw new g("Graph.findNode: expecting a callback.");const t=this._nodes.values();let i,n;for(;i=t.next(),i.done!==!0;)if(n=i.value,e(n.key,n.attributes))return n.key}mapNodes(e){if(typeof e!="function")throw new g("Graph.mapNode: expecting a callback.");const t=this._nodes.values();let i,n;const o=new Array(this.order);let s=0;for(;i=t.next(),i.done!==!0;)n=i.value,o[s++]=e(n.key,n.attributes);return o}someNode(e){if(typeof e!="function")throw new g("Graph.someNode: expecting a callback.");const t=this._nodes.values();let i,n;for(;i=t.next(),i.done!==!0;)if(n=i.value,e(n.key,n.attributes))return!0;return!1}everyNode(e){if(typeof e!="function")throw new g("Graph.everyNode: expecting a callback.");const t=this._nodes.values();let i,n;for(;i=t.next(),i.done!==!0;)if(n=i.value,!e(n.key,n.attributes))return!1;return!0}filterNodes(e){if(typeof e!="function")throw new g("Graph.filterNodes: expecting a callback.");const t=this._nodes.values();let i,n;const o=[];for(;i=t.next(),i.done!==!0;)n=i.value,e(n.key,n.attributes)&&o.push(n.key);return o}reduceNodes(e,t){if(typeof e!="function")throw new g("Graph.reduceNodes: expecting a callback.");if(arguments.length<2)throw new g("Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.");let i=t;const n=this._nodes.values();let o,s;for(;o=n.next(),o.done!==!0;)s=o.value,i=e(i,s.key,s.attributes);return i}nodeEntries(){const e=this._nodes.values();return new G(()=>{const t=e.next();if(t.done)return t;const i=t.value;return{value:{node:i.key,attributes:i.attributes},done:!1}})}export(){const e=new Array(this._nodes.size);let t=0;this._nodes.forEach((n,o)=>{e[t++]=Rr(o,n)});const i=new Array(this._edges.size);return t=0,this._edges.forEach((n,o)=>{i[t++]=Fr(this.type,o,n)}),{options:{type:this.type,multi:this.multi,allowSelfLoops:this.allowSelfLoops},attributes:this.getAttributes(),nodes:e,edges:i}}import(e,t=!1){if(e instanceof v)return e.forEachNode((d,u)=>{t?this.mergeNode(d,u):this.addNode(d,u)}),e.forEachEdge((d,u,h,c,f,p,w)=>{t?w?this.mergeUndirectedEdgeWithKey(d,h,c,u):this.mergeDirectedEdgeWithKey(d,h,c,u):w?this.addUndirectedEdgeWithKey(d,h,c,u):this.addDirectedEdgeWithKey(d,h,c,u)}),this;if(!$(e))throw new g("Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.");if(e.attributes){if(!$(e.attributes))throw new g("Graph.import: invalid attributes. Expecting a plain object.");t?this.mergeAttributes(e.attributes):this.replaceAttributes(e.attributes)}let i,n,o,s,a;if(e.nodes){if(o=e.nodes,!Array.isArray(o))throw new g("Graph.import: invalid nodes. Expecting an array.");for(i=0,n=o.length;i<n;i++){s=o[i],Wr(s);const{key:d,attributes:u}=s;t?this.mergeNode(d,u):this.addNode(d,u)}}if(e.edges){let d=!1;if(this.type==="undirected"&&(d=!0),o=e.edges,!Array.isArray(o))throw new g("Graph.import: invalid edges. Expecting an array.");for(i=0,n=o.length;i<n;i++){a=o[i],Kr(a);const{source:u,target:h,attributes:c,undirected:f=d}=a;let p;"key"in a?(p=t?f?this.mergeUndirectedEdgeWithKey:this.mergeDirectedEdgeWithKey:f?this.addUndirectedEdgeWithKey:this.addDirectedEdgeWithKey,p.call(this,a.key,u,h,c)):(p=t?f?this.mergeUndirectedEdge:this.mergeDirectedEdge:f?this.addUndirectedEdge:this.addDirectedEdge,p.call(this,u,h,c))}}return this}nullCopy(e){const t=new v(k({},this._options,e));return t.replaceAttributes(k({},this.getAttributes())),t}emptyCopy(e){const t=this.nullCopy(e);return this._nodes.forEach((i,n)=>{const o=k({},i.attributes);i=new t.NodeDataClass(n,o),t._nodes.set(n,i)}),t}copy(e){if(e=e||{},typeof e.type=="string"&&e.type!==this.type&&e.type!=="mixed")throw new y(`Graph.copy: cannot create an incompatible copy from "${this.type}" type to "${e.type}" because this would mean losing information about the current graph.`);if(typeof e.multi=="boolean"&&e.multi!==this.multi&&e.multi!==!0)throw new y("Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.");if(typeof e.allowSelfLoops=="boolean"&&e.allowSelfLoops!==this.allowSelfLoops&&e.allowSelfLoops!==!0)throw new y("Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.");const t=this.emptyCopy(e),i=this._edges.values();let n,o;for(;n=i.next(),n.done!==!0;)o=n.value,ot(t,"copy",!1,o.undirected,o.key,o.source.key,o.target.key,k({},o.attributes));return t}toJSON(){return this.export()}toString(){return"[object Graph]"}inspect(){const e={};this._nodes.forEach((o,s)=>{e[s]=o.attributes});const t={},i={};this._edges.forEach((o,s)=>{const a=o.undirected?"--":"->";let d="",u=o.source.key,h=o.target.key,c;o.undirected&&u>h&&(c=u,u=h,h=c);const f=`(${u})${a}(${h})`;s.startsWith("geid_")?this.multi&&(typeof i[f]>"u"?i[f]=0:i[f]++,d+=`${i[f]}. `):d+=`[${s}]: `,d+=f,t[d]=o.attributes});const n={};for(const o in this)this.hasOwnProperty(o)&&!De.has(o)&&typeof this[o]!="function"&&typeof o!="symbol"&&(n[o]=this[o]);return n.attributes=this._attributes,n.nodes=e,n.edges=t,A(n,"constructor",this.constructor),n}}typeof Symbol<"u"&&(v.prototype[Symbol.for("nodejs.util.inspect.custom")]=v.prototype.inspect);qr.forEach(r=>{["add","merge","update"].forEach(e=>{const t=r.name(e),i=e==="add"?ot:Jr;r.generateKey?v.prototype[t]=function(n,o,s){return i(this,t,!0,(r.type||this.type)==="undirected",null,n,o,s,e==="update")}:v.prototype[t]=function(n,o,s,a){return i(this,t,!1,(r.type||this.type)==="undirected",n,o,s,a,e==="update")}})});or(v);yr(v);Cr(v);Mr(v);class st extends v{constructor(e){const t=k({type:"directed"},e);if("multi"in t&&t.multi!==!1)throw new g("DirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if(t.type!=="directed")throw new g('DirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}}class at extends v{constructor(e){const t=k({type:"undirected"},e);if("multi"in t&&t.multi!==!1)throw new g("UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if(t.type!=="undirected")throw new g('UndirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}}class ut extends v{constructor(e){const t=k({multi:!0},e);if("multi"in t&&t.multi!==!0)throw new g("MultiGraph.from: inconsistent indication that the graph should be simple in given options!");super(t)}}class re extends v{constructor(e){const t=k({type:"directed",multi:!0},e);if("multi"in t&&t.multi!==!0)throw new g("MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if(t.type!=="directed")throw new g('MultiDirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}}class dt extends v{constructor(e){const t=k({type:"undirected",multi:!0},e);if("multi"in t&&t.multi!==!0)throw new g("MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if(t.type!=="undirected")throw new g('MultiUndirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}}function B(r){r.from=function(e,t){const i=k({},e.options,t),n=new r(i);return n.import(e),n}}B(v);B(st);B(at);B(ut);B(re);B(dt);v.Graph=v;v.DirectedGraph=st;v.UndirectedGraph=at;v.MultiGraph=ut;v.MultiDirectedGraph=re;v.MultiUndirectedGraph=dt;v.InvalidArgumentsGraphError=g;v.NotFoundGraphError=l;v.UsageGraphError=y;var pe=(r=>(r.Command="command",r.CommandSuccessResponse="commandSuccessResponse",r.CommandErrorResponse="commandErrorResponse",r.InfoServiceInit="infoServiceInit",r.InfoServiceReady="infoServiceReady",r.InfoServiceNotReady="infoServiceNotReady",r.InfoServiceFunctionAdded="infoServiceFunctionAdded",r.InfoServiceDrain="infoServiceDrain",r.InfoServiceShutdown="infoServiceShutdown",r.InfoInvokeTimeout="infoInvokeTimeout",r.InfoSubscriptionError="infoSubscriptionError",r.CustomMessage="customMessage",r))(pe||{}),F=(r=>(r.Invoke="invokes",r.Subscribes="subscribes",r))(F||{}),O=(r=>(r.Command="command",r.Subscription="subscription",r.Endpoint="endpoint",r))(O||{});const fi=r=>r.graphNodeType===O.Command,li=r=>r.graphNodeType===O.Subscription,Xr=r=>r.graphNodeType===O.Endpoint;var W=(r=>(r.Invokes="invokes",r.Subscribes="subscribes",r))(W||{});const Qr=(r,e)=>{L.debug("generating graph");const t=[];return e.forEach(i=>{i.commands.forEach(n=>{r.addNode(R(i.name,i.version,n.name),{serviceName:i.name,serviceVersion:i.version,graphNodeType:O.Command,...n,deprecated:i.deprecated||n.deprecated}),n.restApi&&r.addNode(he(i.version,n.restApi.method,n.restApi.path),{...n.restApi,name:`${n.restApi.method}: v${i.version}/${n.restApi.path}`,title:n.name,description:n.description,summary:n.restApi.summary,serviceName:i.name,serviceVersion:i.version,serviceTarget:n.name,graphNodeType:O.Endpoint,outputSchema:n.outputSchema,inputSchema:n.inputSchema})}),i.subscriptions.forEach(n=>{r.addNode(ee(i.name,i.version,n.name),{serviceName:i.name,serviceVersion:i.version,graphNodeType:O.Subscription,...n,deprecated:i.deprecated||n.deprecated})})}),e.forEach(i=>{i.commands.forEach(n=>{const o=R(i.name,i.version,n.name);if(n.invokes.forEach(s=>{const a=R(s.serviceName,s.serviceVersion,s.serviceTarget);r.addDirectedEdge(o,a,{label:F.Invoke,relation:W.Invokes})}),n.restApi){const s=he(i.version,n.restApi.method,n.restApi.path);r.addDirectedEdge(s,o,{label:F.Invoke,relation:W.Invokes})}}),i.subscriptions.forEach(n=>{const o=ee(i.name,i.version,n.name);n.invokes.forEach(s=>{const a=R(s.serviceName,s.serviceVersion,s.serviceTarget);r.addDirectedEdge(o,a,{label:F.Invoke,relation:W.Invokes})}),e.forEach(s=>s.commands.forEach(a=>{const d=R(s.name,s.version,a.name),u={messageType:pe.CommandSuccessResponse,sender:{serviceName:s.name,serviceVersion:s.version,serviceTarget:a.name},eventName:a.eventName};xe(n,u)&&r.addDirectedEdge(d,o,{label:F.Subscribes,relation:W.Subscribes})})),e.forEach(s=>s.subscriptions.forEach(a=>{const d=ee(s.name,s.version,a.name),u={messageType:pe.CommandSuccessResponse,sender:{serviceName:s.name,serviceVersion:s.version,serviceTarget:a.name},eventName:a.eventName};xe(n,u)&&r.addDirectedEdge(d,o,{label:F.Subscribes,relation:W.Subscribes})}))})}),{events:t}},pi=Ce("services",{state:()=>({graph:new re,services:[],events:[]}),getters:{getServiceByNameAndVersion:r=>(e,t)=>r.services.find(i=>i.name===e&&i.version===t),servicesGroupedByName:r=>{const e=new Map;r.services.forEach(i=>{let n=e.get(i.name);n||(n=[]),n.push(i);const o=Ae(n).by({desc:s=>s.version,comparer:new Intl.Collator(void 0,{numeric:!0,sensitivity:"base"}).compare});e.set(i.name,o)});const t=Array.from(e.values());return Ae(t).by({asc:i=>i[0].name,comparer:new Intl.Collator(void 0,{numeric:!0,sensitivity:"base"}).compare})},getCommandByServiceAndName:r=>(e,t,i)=>{try{const n=R(e,t,i);return r.graph.getNodeAttributes(n)}catch(n){L.error({err:n,name:e,version:t,commandName:i},"getCommandByServiceAndName");return}},getSubscriptionByServiceAndName:r=>(e,t,i)=>{try{const n=ee(e,t,i);return r.graph.getNodeAttributes(n)}catch(n){L.error({err:n,name:e,version:t,subscriptionName:i},"getSubscriptionByServiceAndName");return}},getEndpointByServiceAndName:r=>(e,t,i)=>{try{const n=he(e,t,i);return r.graph.getNodeAttributes(n)}catch(n){L.error({err:n,version:e,method:t,path:i},"getEndpointByServiceAndName");return}},allEvents:r=>r.events,allEndpoints:r=>r.graph.reduceNodes((e,t,i)=>Xr(i)?[...e,i]:e,[]),getCommandsInvokedBy:r=>e=>{try{return Array.from(r.graph.outboundNeighborEntries(e),t=>t.attributes).filter(t=>t.graphNodeType===O.Command)}catch(t){return L.error({err:t,id:e},"getCommandsInvokedBy"),[]}},getConsumingSubscriptions:r=>e=>{try{return Array.from(r.graph.outboundNeighborEntries(e),t=>t.attributes).filter(t=>t.graphNodeType===O.Subscription)}catch(t){return L.error({err:t,id:e},"getSubscribedSubscription"),[]}},getGraphNode:r=>e=>{try{return r.graph.getNodeAttributes(e)}catch(t){L.error({err:t,id:e},"getGraphNode")}},getInputNodes:r=>e=>{try{return Array.from(r.graph.inboundNeighborEntries(e),t=>t.attributes)}catch(t){return L.error({err:t,id:e},"getSubscribedSubscription"),[]}}},actions:{init(r){this.services=r,this.graph=new re;const{events:e}=Qr(this.graph,r);this.events=e}}}),Zr={name:"BankAccount",version:"1",description:"Manages users bank account",commands:[],subscriptions:[],markdown:`
# About the BankAccount service

Example readme text
If a readme file exists in the root of a service version, the content can be included here.

As we are developers, we want to have code snippets as well:

\`\`\`typescript
const x = 1

const y = (some: string):string => some
\`\`\`

Maybe we also want to include some mermaid diagram to explain something more visual:

\`\`\`mermaid
graph TD
    A[User] -->|Sign up| B(Onboarding)
    B --> C{Provide products}
    C -->|Hold| D[Account]
    C -->|Use| E[Card]
    C -->|Invest| F[Shares]
\`\`\`
`},ei={name:"Card",version:"1",description:"Manages the users credit card",commands:[],subscriptions:[],markdown:`
# About the Card service

Example readme text
If a readme file exists in the root of a service version, the content can be included here.

As we are developers, we want to have code snippets as well:

\`\`\`typescript
const x = 1

const y = (some: string):string => some
\`\`\`

Maybe we also want to include some mermaid diagram to explain something more visual:

\`\`\`mermaid
graph TD
    A[User] -->|Sign up| B(Onboarding)
    B --> C{Provide products}
    C -->|Hold| D[Account]
    C -->|Use| E[Card]
    C -->|Invest| F[Shares]
\`\`\`
`},ti={name:"sendEmailVerification",description:"Sends an email with some verification link",markdown:"",subscribesTo:{eventname:"validation-token-created",sender:{name:"Identity"}},invokes:[],publishesCustomEvents:[],outputSchema:{type:"object",properties:{id:{type:"string",title:"the unique user id of user",format:"uuid"},token:{type:"string",title:"the unique user id of user",format:"uuid"}}}},ri={name:"Email",version:"1",description:"Handles outgoing emails",commands:[],subscriptions:[ti],markdown:`
# About the Email service

Example readme text
If a readme file exists in the root of a service version, the content can be included here.

As we are developers, we want to have code snippets as well:

\`\`\`typescript
const x = 1

const y = (some: string):string => some
\`\`\`

Maybe we also want to include some mermaid diagram to explain something more visual:

\`\`\`mermaid
graph TD
    A[User] -->|Sign up| B(Onboarding)
    B --> C{Provide products}
    C -->|Hold| D[Account]
    C -->|Use| E[Card]
    C -->|Invest| F[Shares]
\`\`\`
`},ii={name:"createEmailValidateToken",description:"Creates a token used for email validation",markdown:`The _createEmailValidateToken_ subscription listens for all new created users.

To verify a users email address, a one-time random generated key will be created.  
This key is part of the confirmation link, which is sent to the user.

The user needs to verify teh email address to continue the onboarding process.
`,eventName:"validation-token-created",subscribesTo:{eventname:"new-user-registered",sender:{name:"User"}},invokes:[{serviceName:"User",serviceVersion:"1",serviceTarget:"getUserById"}],publishesCustomEvents:[],inputSchema:{type:"object",properties:{id:{type:"string",title:"the unique user id of user",format:"uuid"},firstName:{type:"string",title:"first name of user",example:"Sherlock"},lastName:{type:"string",title:"last name of user",example:"Holmes"},gender:{type:"string",example:"male",enum:["male","female","other"]},email:{type:"string",title:"email of user",example:"catch-moriarty@holmes.com",format:"email"}},required:["id","firstName","lastName","gender","email"],title:"root test object"},outputSchema:{type:"object",properties:{id:{type:"string",title:"the unique user id of user",format:"uuid"},token:{type:"string",title:"the unique user id of user",format:"uuid"}}}},ni={name:"Identity",version:"1",description:"Verifies the users identity",commands:[],subscriptions:[ii],markdown:`
# About the Identity service

Example readme text
If a readme file exists in the root of a service version, the content can be included here.

As we are developers, we want to have code snippets as well:

\`\`\`typescript
const x = 1

const y = (some: string):string => some
\`\`\`

Maybe we also want to include some mermaid diagram to explain something more visual:

\`\`\`mermaid
graph TD
    A[User] -->|Sign up| B(Onboarding)
    B --> C{Provide products}
    C -->|Hold| D[Account]
    C -->|Use| E[Card]
    C -->|Invest| F[Shares]
\`\`\`
`},ct={name:"getUserById",description:"Returns user information for given id",markdown:"",invokes:[],publishesCustomEvents:[],inputSchema:{type:"object",properties:{id:{type:"string",title:"the unique user id of user",format:"uuid"}},required:["id"],title:"root test object"},restApi:{method:"GET",path:"users/:userId",parameter:[],tags:[],errorCodes:[],isProtected:!0,isDeprecated:!1},outputSchema:{type:"object",title:"Signup user information",properties:{id:{type:"string",title:"the unique user id of user",format:"uuid"},firstName:{type:"string",title:"first name of user",example:"Sherlock"},lastName:{type:"string",title:"last name of user",example:"Holmes"},gender:{type:"string",example:"male",enum:["male","female","other"]},mobile:{type:"string",title:"mobile phone number",example:"+497700900000"},email:{type:"string",title:"email of user",example:"catch-moriarty@holmes.com",format:"email"},birthday:{type:"string",title:"date of birth",example:"1854-06-02",format:"date"},address:{type:"object",title:"address of user",properties:{line1:{type:"string",title:"address line one",example:"Baker Street 221B"},line2:{type:"string",title:"address line two",example:"1st floor"},city:{type:"string",title:"city name",example:"London"},zip:{type:"string",title:"the zip code",example:"NW1 6XE"},country:{type:"string",title:"the country code",example:"UK"}},required:["line1","line2","city","zip","country"]},nationality:{type:"string",title:"the nationality of the user",example:"UK"},hints:{type:"string",title:"some optional free text for the user",example:"please contact me only via mail"}},required:["id","firstName","lastName","gender","email","birthday","address","nationality"]}},ht={name:"userSignUp",eventName:"new-user-registered",description:"Registers a new user",markdown:`Even single commands can have some markdown content rendered, if they provide a _readme.md_.  
Also here, we can have some code example:

\`\`\`typescript
const example = () => 'my command documentation code example'
\`\`\`

We also can have some nice mermaid:

\`\`\`mermaid
graph LR
    A[User] -->|Opens the app| B[Onboarding]
    B -->|collecting information| C(Calling REST-API /new)
\`\`\`
`,restApi:{method:"POST",path:"signUp",parameter:[],tags:[],errorCodes:[],isProtected:!1,isDeprecated:!1},invokes:[],publishesCustomEvents:[],inputSchema:{type:"object",title:"Signup user information",description:"The payload sent via HTTP-POST request",properties:{firstName:{type:"string",title:"first name of user",example:"Sherlock"},lastName:{type:"string",title:"last name of user",example:"Holmes"},gender:{type:"string",example:"male",enum:["male","female","other"]},mobile:{type:"string",title:"mobile phone number",example:"+497700900000"},email:{type:"string",title:"email of user",example:"catch-moriarty@holmes.com",format:"email"},birthday:{type:"string",title:"date of birth",example:"1854-06-02",format:"date"},address:{type:"object",title:"address of user",properties:{line1:{type:"string",title:"address line one",example:"Baker Street 221B"},line2:{type:"string",title:"address line two",example:"1st floor"},city:{type:"string",title:"city name",example:"London"},zip:{type:"string",title:"the zip code",example:"NW1 6XE"},country:{type:"string",title:"the country code",example:"UK"}},required:["line1","line2","city","zip","country"]},nationality:{type:"string",title:"the nationality of the user",example:"UK"},password:{type:"string",title:"the encrypted password",example:"==678dfdjklklsdfkdssddkf89wwoladldsfsf"},cv:{type:"string",title:"The cv to for encryption",example:"==9089jkljkll"},hints:{type:"string",title:"some optional free text for the user",example:"please contact me only via mail"}},required:["firstName","lastName","gender","email","birthday","address","nationality","password","cv"]},parameterSchema:{type:"object",title:"Parameter example",description:"The parameters provided during command invocation",properties:{sessionId:{type:"string",title:"the current session id of the user",format:"uuid"}}},outputSchema:{type:"object",title:"The output schema",description:"contains the unique user id",properties:{id:{type:"string",title:"the unique user id of user",format:"uuid"},firstName:{type:"string",title:"first name of user",example:"Sherlock"},lastName:{type:"string",title:"last name of user",example:"Holmes"},gender:{type:"string",example:"male",enum:["male","female","other"]},email:{type:"string",title:"email of user",example:"catch-moriarty@holmes.com",format:"email"}},required:["id","firstName","lastName","gender","email"]}},oi={name:"User",version:"1",description:"Manages users and user information",commands:[ht,ct],subscriptions:[],deprecated:!0,markdown:`
# About the User service

Example readme text
If a readme file exists in the root of a service version, the content can be included here.

As we are developers, we want to have code snippets as well:

\`\`\`typescript
const x = 1

const y = (some: string):string => some
\`\`\`

Maybe we also want to include some mermaid diagram to explain something more visual:

\`\`\`mermaid
graph TD
    A[User] -->|Sign up| B(Onboarding)
    B --> C{Provide products}
    C -->|Hold| D[Account]
    C -->|Use| E[Card]
    C -->|Invest| F[Shares]
\`\`\`
`},si={name:"User",version:"2",description:"Manages users and user information",commands:[ht,ct],subscriptions:[],markdown:`
# About the User service

Example readme text
If a readme file exists in the root of a service version, the content can be included here.

As we are developers, we want to have code snippets as well:

\`\`\`typescript
const x = 1

const y = (some: string):string => some
\`\`\`

Maybe we also want to include some mermaid diagram to explain something more visual:

\`\`\`mermaid
graph TD
    A[User] -->|Sign up| B(Onboarding)
    B --> C{Provide products}
    C -->|Hold| D[Account]
    C -->|Use| E[Card]
    C -->|Invest| F[Shares]
\`\`\`
`},ai=[oi,si,ri,ni,Zr,ei],ui={id:"demo",name:"Example demo",description:"A simple example for Voyage",markdown:`
This is an example project which demonstrates the basic features of PURISTA Voyage.
`,services:ai},gi=Ce("projects",()=>{const r=ke([ui]),e=ke();return{isProjectSelected:ft(()=>!!e.value),activeProject:e,setProjectActive:function(n){const o=r.value.find(s=>s.id===n);return o?(e.value=o,!0):!1},projects:r}});export{F as E,O as N,ee as a,ie as b,ci as c,fi as d,Xr as e,he as f,R as g,hi as h,li as i,gi as j,L as l,Ae as s,pi as u};
